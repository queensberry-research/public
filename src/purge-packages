#!/usr/bin/env python3
import re
import reprlib
from collections.abc import Iterable, Iterator, Mapping
from collections.abc import Set as AbstractSet
from dataclasses import dataclass
from logging import basicConfig, getLogger
from pathlib import Path

_LOGGER = getLogger(__name__)
basicConfig(
    format="{asctime} | {message}", datefmt="%Y-%m-%d %H:%M:%S", style="{", level="INFO"
)
_PATTERN = re.compile(r"^(\w+)\-(\d+)\.(\d+)\.(\d+)\-py3\-none\-any\.whl$")


def main() -> None:
    packages = list(_yield_packages())
    _LOGGER.info("Got %d packages: %s", len(packages), reprlib.repr(packages))
    for name, packages_n in _group_packages(packages).items():
        _purge_group(name, packages_n)


def _yield_packages() -> Iterator["Package"]:
    _LOGGER.info("Yielding packages...")
    for path in Path.cwd().iterdir():
        if path.is_file():
            try:
                ((name, major, minor, patch),) = _PATTERN.findall(path.name)
            except ValueError:
                pass
            else:
                yield Package(
                    path=path,
                    name=name,
                    major=int(major),
                    minor=int(minor),
                    patch=int(patch),
                )


@dataclass(order=True, frozen=True)
class Package:
    path: Path
    name: str
    major: int
    minor: int
    patch: int

    @property
    def major_minor(self) -> "MajorMinorVersion":
        return MajorMinorVersion(major=self.major, minor=self.minor)


@dataclass(order=True, frozen=True)
class MajorMinorVersion:
    major: int
    minor: int

    def __repr__(self) -> str:
        return f"{self.major}.{self.minor}"


def _group_packages(
    packages: Iterable[Package], /
) -> Mapping[str, Mapping[MajorMinorVersion, AbstractSet[Package]]]:
    _LOGGER.info("Grouping packages...")
    result: dict[str, dict[MajorMinorVersion, set[Package]]] = {}
    for package in packages:
        if (name := package.name) not in result:
            result[name] = {}
        if (major_minor := package.major_minor) not in result[name]:
            result[name][major_minor] = set()
        result[name][major_minor].add(package)
    _LOGGER.info("Got %d group(s): %s", len(result), reprlib.repr(result))
    return result


def _purge_group(
    name: str, packages: Mapping[MajorMinorVersion, AbstractSet[Package]], /
) -> None:
    items = sorted(packages.items(), key=lambda x: x[0])
    _LOGGER.info(
        "Group %r has %d version(s): %s", name, len(items), repr([v for v, _ in items])
    )
    if len(items) <= 2:
        _LOGGER.info("Group %r has nothing to purge", name)
        return
    *old_items, _, _ = items
    for version, packages_v in old_items:
        for package in sorted(packages_v):
            _LOGGER.info(
                "Group %r/version %s: purging %r...", name, version, str(package.path)
            )
            package.path.unlink(missing_ok=True)


main()
